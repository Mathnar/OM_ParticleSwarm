# -*- coding: utf-8 -*-
"""PartSwOpt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hiTqLRyVnP-WHuSbMcUYGMLFu_raDxqu
"""

#*
################################################################################################################
#Authors: Fernando Chirici 7051275
#         Damiano Giani 7062241
#Project: Progetto di Optimization Methods: Analisi e sperimentazione di Particle Swarm Optimization
#Department: Ingegneria Informatica Magistrale - Università degli studi di Firenze 2020/2021
################################################################################################################
#*
import random
import math
import matplotlib.pyplot as plt
import numpy as np

def rastrigin(X):
    A = 10
    y = A * 2 + sum([(x ** 2 - A * np.cos(2 * math.pi * x)) for x in X])
    return y
bounds = [(-5.12, 5.12), (-5.12, 5.12)]

def sphere(X):
    y = sum([(x ** 2) for x in X])
    return y

bounds1 = [(-5.12, 5.12), (-5.12, 5.12),(-5.12, 5.12), (-5.12, 5.12)]

def eggholder(x):
    y=(-(x[1] + 47) * np.sin(np.sqrt(abs(x[0]/2 + (x[1]  + 47))))-x[0] * np.sin(np.sqrt(abs(x[0] - (x[1]  + 47)))))

    return y

bounds2 = [(-512, 512), (-512, 512)]

fig = plt.figure()
ax = fig.add_subplot()
fig.show()


class Particle:
    def __init__(self, bounds,parameter,nv):
        self.nv=nv
        self.c1=parameter[0]
        self.c2=parameter[1]
        self.particle_pos = []  # posizione
        self.particle_vel = []  # velocità
        self.local_best_part_pos = []  # best particle position
        self.best_part_init_objFv = float("inf")  # best particle position del primo val funzione obbiettivo
        self.part_pos_objFv = float("inf")  # objective function value of the particle position

        for i in range(self.nv):
            self.particle_pos.append(
                random.uniform(bounds[i][0], bounds[i][1]))  # generate random initial p
            self.particle_vel.append(random.uniform(-1, 1))  # generate random initial v

    def evaluate(self, objective_function):
        self.part_pos_objFv = objective_function(self.particle_pos)#valore della funzione
        if self.part_pos_objFv < self.best_part_init_objFv:
            self.local_best_part_pos = self.particle_pos  # aggiorno migliore locale #
            self.best_part_init_objFv = self.part_pos_objFv  # aggiorno posizione migliore locale #valore

    def update_v(self, global_best_particle_position,w):
        for i in range(self.nv):
            r1 = random.random()
            r2 = random.random()
            cognitive_velocity = self.c1 * r1 * (self.local_best_part_pos[i] - self.particle_pos[i])
            social_velocity = self.c2 * r2 * (global_best_particle_position[i] - self.particle_pos[i])
            self.particle_vel[i] = w * self.particle_vel[i] + cognitive_velocity + social_velocity

    def update_p(self, bounds):
        for i in range(self.nv):
            self.particle_pos[i] = self.particle_pos[i] + self.particle_vel[i]
            if self.particle_pos[i] > bounds[i][1]:  # controllo sui limiti
                self.particle_pos[i] = bounds[i][1]
            if self.particle_pos[i] < bounds[i][0]:
                self.particle_pos[i] = bounds[i][0]


def run(objective_function, bounds, parameter,nv,p_size,iter,choose_w):#w 0,1

    particle_size = p_size  # num partcles
    iterations = iter  # 100  # max num iter

    global_best_particle_position_value = float("inf")
    global_best_particle_position = []
    swarm_particle = []

    for i in range(particle_size):
        swarm_particle.append(Particle(bounds,parameter,nv))

    for i in range(iterations):
        if choose_w==0:
            w = 0.75
        elif choose_w==1:
            w = 0.5 + random.uniform(0.0, 1.0) / 2
        for j in range(particle_size):
            swarm_particle[j].evaluate(objective_function)
            if swarm_particle[j].part_pos_objFv < global_best_particle_position_value:
                global_best_particle_position = list(swarm_particle[j].particle_pos)
                global_best_particle_position_value = float(swarm_particle[j].part_pos_objFv)
        for j in range(particle_size):
            swarm_particle[j].update_v(global_best_particle_position,w)
            swarm_particle[j].update_p(bounds)

    print('Optimal solution: ', global_best_particle_position)
    print('Objective funtion value: ', global_best_particle_position_value)
    return global_best_particle_position_value,global_best_particle_position  

#run(rastrigin, bounds,[2.05,2.05],len(bounds),50,100,0)
#run(sphere, bounds1,[2.05,2.05],len(bounds1),50,100,0)
#run(eggholder,bounds2,[2.05,2.05],len(bounds2),50,100,0)

res=[] 
iter=[]
for i in range(0,50):
  iter.append(i)
  res.append(run(eggholder,bounds2,[2.05,2.05],len(bounds2),50,100,0)[0]) #esecuzione test (50 test)


########################
#######  PLOT   ########
########################
line3=plt.plot(iter,res, '-', color="green")
plt.xlabel('Iteration')
plt.ylabel('global_best_particle_position_value')
plt.grid()
plt.savefig('iters.png')
plt.show()

values=[]
times=[]

for i in range(0,len(res)): 
  if  round(res[i], 2) not in values: 
    values.append(round(res[i], 2))
    times.append(0)

for i in range(0,len(values)):
  for j in range(0,len(res)):    
    if values[i]==round(res[j], 2):
      times[i]=times[i]+1

for i in range(0,len(values)):
  print("\nvalue ", values[i], "- " ,"times: ", times[i])

labels = values
sizes = times

fig1, ax1 = plt.subplots(figsize=(6, 5))
fig1.subplots_adjust(0.3,0,1,1)


theme = plt.get_cmap('bwr')

_, _ = ax1.pie(sizes, startangle=90)

ax1.axis('equal')

total = sum(sizes)
plt.legend(
    loc='upper left',
    labels=['%s, %1.1f%%' % (
        l, (float(s) / total) * 100) for l, s in zip(labels, sizes)],
    prop={'size': 11},
    bbox_to_anchor=(0.0, 1),
    bbox_transform=fig1.transFigure
)
plt.savefig('pie.png')
plt.show()

"""# New Section"""



#*
################################################################################################################
#Authors: Fernando Chirici 7051275
#         Damiano Giani 7062241
#Project: Progetto di Optimization Methods: Analisi e sperimentazione di Particle Swarm Optimization
#Department: Ingegneria Informatica Magistrale - Università degli studi di Firenze 2020/2021
################################################################################################################
#*
import random
import math
import matplotlib.pyplot as plt
import numpy as np

def rastrigin(X):
    A = 10
    y = A * 2 + sum([(x ** 2 - A * np.cos(2 * math.pi * x)) for x in X])
    return y
bounds = [(-5.12, 5.12), (-5.12, 5.12)]

def sphere(X):
    y = sum([(x ** 2) for x in X])
    return y

bounds1 = [(-5.12, 5.12), (-5.12, 5.12),(-5.12, 5.12), (-5.12, 5.12)]

def eggholder(x):
    y=(-(x[1] + 47) * np.sin(np.sqrt(abs(x[0]/2 + (x[1]  + 47))))-x[0] * np.sin(np.sqrt(abs(x[0] - (x[1]  + 47)))))

    return y

bounds2 = [(-512, 512), (-512, 512)]

fig = plt.figure()
ax = fig.add_subplot()
fig.show()


class Particle:
    def __init__(self, bounds,parameter,nv):
        self.nv=nv
        self.c1=parameter[0]
        self.c2=parameter[1]
        self.particle_pos = []  # posizione
        self.particle_vel = []  # velocità
        self.local_best_part_pos = []  # best particle position
        self.best_part_init_objFv = float("inf")  # best particle position del primo val funzione obbiettivo
        self.part_pos_objFv = float("inf")  # objective function value of the particle position

        for i in range(self.nv):
            self.particle_pos.append(
                random.uniform(bounds[i][0], bounds[i][1]))  # generate random initial p
            self.particle_vel.append(random.uniform(-1, 1))  # generate random initial v

    def evaluate(self, objective_function):
        self.part_pos_objFv = objective_function(self.particle_pos)#valore della funzione
        if self.part_pos_objFv < self.best_part_init_objFv:
            self.local_best_part_pos = self.particle_pos  # aggiorno migliore locale #
            self.best_part_init_objFv = self.part_pos_objFv  # aggiorno posizione migliore locale #valore

    def update_v(self, global_best_particle_position,w):
        for i in range(self.nv):
            r1 = random.random()
            r2 = random.random()
            cognitive_velocity = self.c1 * r1 * (self.local_best_part_pos[i] - self.particle_pos[i])
            social_velocity = self.c2 * r2 * (global_best_particle_position[i] - self.particle_pos[i])
            self.particle_vel[i] = w * self.particle_vel[i] + cognitive_velocity + social_velocity

    def update_p(self, bounds):
        for i in range(self.nv):
            self.particle_pos[i] = self.particle_pos[i] + self.particle_vel[i]
            if self.particle_pos[i] > bounds[i][1]:  # controllo sui limiti
                self.particle_pos[i] = bounds[i][1]
            if self.particle_pos[i] < bounds[i][0]:
                self.particle_pos[i] = bounds[i][0]


def run(objective_function, bounds, parameter,nv,p_size,iter,choose_w):#w 0,1

    particle_size = p_size  # num partcles
    iterations = iter  # 100  # max num iter

    global_best_particle_position_value = float("inf")
    global_best_particle_position = []
    swarm_particle = []

    for i in range(particle_size):
        swarm_particle.append(Particle(bounds,parameter,nv))

    for i in range(iterations):
        if choose_w==0:
            w = 0.75
        elif choose_w==1:
            w = 0.5 + random.uniform(0.0, 1.0) / 2
        for j in range(particle_size):
            swarm_particle[j].evaluate(objective_function)
            if swarm_particle[j].part_pos_objFv < global_best_particle_position_value:
                global_best_particle_position = list(swarm_particle[j].particle_pos)
                global_best_particle_position_value = float(swarm_particle[j].part_pos_objFv)
        for j in range(particle_size):
            swarm_particle[j].update_v(global_best_particle_position,w)
            swarm_particle[j].update_p(bounds)

    print('Optimal solution: ', global_best_particle_position)
    print('Objective funtion value: ', global_best_particle_position_value)
    return global_best_particle_position_value,global_best_particle_position  

#run(rastrigin, bounds,[2.05,2.05],len(bounds),50,100,0)
#run(sphere, bounds1,[2.05,2.05],len(bounds1),50,100,0)
#run(eggholder,bounds2,[2.05,2.05],len(bounds2),50,100,0)

res=[] 
iter=[]
for i in range(0,50):
  iter.append(i)
  res.append(run(eggholder,bounds2,[2.05,2.05],len(bounds2),50,100,1)[0]) #esecuzione test (50 test)


########################
#######  PLOT   ########
########################
line3=plt.plot(iter,res, '-', color="green")
plt.xlabel('Iteration')
plt.ylabel('global_best_particle_position_value')
plt.grid()
plt.savefig('iters.png')
plt.show()

values=[]
times=[]

for i in range(0,len(res)): 
  if  round(res[i], 2) not in values: 
    values.append(round(res[i], 2))
    times.append(0)

for i in range(0,len(values)):
  for j in range(0,len(res)):    
    if values[i]==round(res[j], 2):
      times[i]=times[i]+1

for i in range(0,len(values)):
  print("\nvalue ", values[i], "- " ,"times: ", times[i])

labels = values
sizes = times

fig1, ax1 = plt.subplots(figsize=(6, 5))
fig1.subplots_adjust(0.3,0,1,1)


theme = plt.get_cmap('bwr')

_, _ = ax1.pie(sizes, startangle=90)

ax1.axis('equal')

total = sum(sizes)
plt.legend(
    loc='upper left',
    labels=['%s, %1.1f%%' % (
        l, (float(s) / total) * 100) for l, s in zip(labels, sizes)],
    prop={'size': 11},
    bbox_to_anchor=(0.0, 1),
    bbox_transform=fig1.transFigure
)
plt.savefig('pie.png')
plt.show()

